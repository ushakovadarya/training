[debug] [zinc] IncrementalCompile -----------
[debug] IncrementalCompile.incrementalCompile
[debug] previous = Stamps for: 37 products, 4 sources, 2 libraries
[debug] current source = Set(${BASE}/src/main/scala/NewExample.scala, ${BASE}/src/main/scala/AkkaActor.scala, ${BASE}/src/main/scala/Hello.scala, ${BASE}/src/main/scala/Coffee.scala, ${BASE}/src/main/scala/StorageClient.scala, ${BASE}/src/main/scala/Pubs.scala)
[debug] > initialChanges = InitialChanges(Changes(added = Set(${BASE}/src/main/scala/Pubs.scala, ${BASE}/src/main/scala/StorageClient.scala), removed = Set(), changed = Set(), unmodified = ...),Set(),Set(),API Changes: Set())
[debug] 
[debug] Initial source changes:
[debug] 	removed: Set()
[debug] 	added: Set(${BASE}/src/main/scala/Pubs.scala, ${BASE}/src/main/scala/StorageClient.scala)
[debug] 	modified: Set()
[debug] Invalidated products: Set()
[debug] External API changes: API Changes: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated classes: Set()
[debug] Sources indirectly invalidated by:
[debug] 	product: Set()
[debug] 	binary dep: Set()
[debug] 	external source: Set()
[debug] All initially invalidated classes: Set()
[debug] All initially invalidated sources:Set(${BASE}/src/main/scala/Pubs.scala, ${BASE}/src/main/scala/StorageClient.scala)
[debug] Initial set of included nodes: 
[debug] compilation cycle 1
[info] compiling 2 Scala sources to E:\Users\566\Desktop\Scala\tranning\target\scala-2.12\classes ...
[debug] Getting org.scala-sbt:compiler-bridge_2.12:1.5.7:compile for Scala 2.12.11
[debug] [zinc] Running cached compiler 7e3c628b for Scala compiler version 2.12.11
[debug] [zinc] The Scala compiler is invoked with:
[debug] 	-bootclasspath
[debug] 	D:\Java\Jdk\jre\lib\resources.jar;D:\Java\Jdk\jre\lib\rt.jar;D:\Java\Jdk\jre\lib\sunrsasign.jar;D:\Java\Jdk\jre\lib\jsse.jar;D:\Java\Jdk\jre\lib\jce.jar;D:\Java\Jdk\jre\lib\charsets.jar;D:\Java\Jdk\jre\lib\jfr.jar;D:\Java\Jdk\jre\classes;C:\Users\566\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\scala-library\2.12.11\scala-library-2.12.11.jar
[debug] 	-classpath
[debug] 	E:\Users\566\Desktop\Scala\tranning\target\scala-2.12\classes;C:\Users\566\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\com\typesafe\akka\akka-actor_2.12\2.5.31\akka-actor_2.12-2.5.31.jar;C:\Users\566\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\com\typesafe\config\1.3.3\config-1.3.3.jar;C:\Users\566\AppData\Local\Coursier\Cache\v1\https\repo1.maven.org\maven2\org\scala-lang\modules\scala-java8-compat_2.12\0.8.0\scala-java8-compat_2.12-0.8.0.jar
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage.Delete...
[debug] Initial set of included nodes: StorageClient.Storage.Delete
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage.Delete)
[debug] Change NamesChange(StorageClient.Storage.Delete,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(StorageClient;Storage;Delete;init;,[Default]), UsedName(Delete,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The StorageClient.Storage.Delete has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(StorageClient;Storage;Delete;init;,[Default]), UsedName(Delete,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage.Delete)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Subscribe...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Subscribe
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Subscribe)
[debug] Change NamesChange(Pubs.PubSubMediator.Subscribe,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(Pubs;PubSubMediator;Subscribe;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(Subscribe,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(subscriber,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Subscribe has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(Pubs;PubSubMediator;Subscribe;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(Subscribe,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(subscriber,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Subscribe)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Unsubscribe...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Unsubscribe
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Unsubscribe)
[debug] Change NamesChange(Pubs.PubSubMediator.Unsubscribe,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(Pubs;PubSubMediator;Unsubscribe;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(Unsubscribe,[Default]), UsedName(eq,[Default]), UsedName(subscriber,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Unsubscribe has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(Pubs;PubSubMediator;Unsubscribe;init;,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(Unsubscribe,[Default]), UsedName(eq,[Default]), UsedName(subscriber,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Unsubscribe)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Unsubscribed...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Unsubscribed
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Unsubscribed)
[debug] Change NamesChange(Pubs.PubSubMediator.Unsubscribed,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unsubscribe,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(Unsubscribed,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(Pubs;PubSubMediator;Unsubscribed;init;,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Unsubscribed has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unsubscribe,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(Unsubscribed,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(Pubs;PubSubMediator;Unsubscribed;init;,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Unsubscribed)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient...
[debug] Initial set of included nodes: StorageClient
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient)
[debug] Change NamesChange(StorageClient,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(actorSystem,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(storage,[Default]), UsedName(delayedInit,[Default]), UsedName(StorageClient,[Default]), UsedName(executionStart,[Default]), UsedName(Storage,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(Client,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName(client,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(args,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(eq,[Default]))) invalidates 1 classes due to The StorageClient has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(actorSystem,[Default]), UsedName(equals,[Default]), UsedName(main,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(storage,[Default]), UsedName(delayedInit,[Default]), UsedName(StorageClient,[Default]), UsedName(executionStart,[Default]), UsedName(Storage,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(Client,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName(client,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(args,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(eq,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Published...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Published
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Published)
[debug] Change NamesChange(Pubs.PubSubMediator.Published,ModifiedNames(changes = UsedName(Pubs;PubSubMediator;Published;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(Published,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(publish,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Published has the following regular definitions changed:
[debug] 	UsedName(Pubs;PubSubMediator;Published;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(Published,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(publish,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Published)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage.GetResult...
[debug] Initial set of included nodes: StorageClient.Storage.GetResult
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage.GetResult)
[debug] Change NamesChange(StorageClient.Storage.GetResult,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(value,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(GetResult,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]), UsedName(StorageClient;Storage;GetResult;init;,[Default]))) invalidates 1 classes due to The StorageClient.Storage.GetResult has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(value,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(GetResult,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]), UsedName(StorageClient;Storage;GetResult;init;,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage.GetResult)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage.Get...
[debug] Initial set of included nodes: StorageClient.Storage.Get
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage.Get)
[debug] Change NamesChange(StorageClient.Storage.Get,ModifiedNames(changes = UsedName(Get,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(StorageClient;Storage;Get;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The StorageClient.Storage.Get has the following regular definitions changed:
[debug] 	UsedName(Get,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(StorageClient;Storage;Get;init;,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage.Get)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage...
[debug] Initial set of included nodes: StorageClient.Storage
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage)
[debug] Change NamesChange(StorageClient.Storage,ModifiedNames(changes = UsedName(process,[Default]), UsedName(Get,[Default]), UsedName($asInstanceOf,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(Ack,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(preStart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(hashCode,[Default]), UsedName(Storage,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(aroundPostStop,[Default]), UsedName(GetResult,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(postRestart,[Default]), UsedName(context,[Implicit]), UsedName(synchronized,[Default]), UsedName(unhandled,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(Put,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(Delete,[Default]), UsedName(sender,[Default]), UsedName(aroundReceive,[Default]), UsedName(isInstanceOf,[Default]), UsedName(preRestart,[Default]), UsedName(getClass,[Default]), UsedName(StorageClient;Storage;init;,[Default]), UsedName(postStop,[Default]), UsedName(self,[Implicit]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(receive,[Default]), UsedName(eq,[Default]), UsedName(supervisorStrategy,[Default]), UsedName(Receive,[Default]))) invalidates 1 classes due to The StorageClient.Storage has the following implicit definitions changed:
[debug] 	UsedName(context,[Implicit]), UsedName(self,[Implicit]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.AlreadySubscribed...
[debug] Initial set of included nodes: Pubs.PubSubMediator.AlreadySubscribed
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.AlreadySubscribed)
[debug] Change NamesChange(Pubs.PubSubMediator.AlreadySubscribed,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(subscribe,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(AlreadySubscribed,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(Pubs;PubSubMediator;AlreadySubscribed;init;,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.AlreadySubscribed has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(subscribe,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(AlreadySubscribed,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(Pubs;PubSubMediator;AlreadySubscribed;init;,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.AlreadySubscribed)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator...
[debug] Initial set of included nodes: Pubs.PubSubMediator
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator)
[debug] Change NamesChange(Pubs.PubSubMediator,ModifiedNames(changes = UsedName(Subscribed,[Default]), UsedName($asInstanceOf,[Default]), UsedName(NotSubscribed,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(Pubs;PubSubMediator;init;,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(preStart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(hashCode,[Default]), UsedName(Publish,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(aroundPostStop,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(GetSubscribers,[Default]), UsedName(Unsubscribed,[Default]), UsedName(finalize,[Default]), UsedName(postRestart,[Default]), UsedName(context,[Implicit]), UsedName(synchronized,[Default]), UsedName(unhandled,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(sender,[Default]), UsedName(aroundReceive,[Default]), UsedName(Name,[Default]), UsedName(Published,[Default]), UsedName(PubSubMediator,[Default]), UsedName(isInstanceOf,[Default]), UsedName(preRestart,[Default]), UsedName(AlreadySubscribed,[Default]), UsedName(getClass,[Default]), UsedName(props,[Default]), UsedName(postStop,[Default]), UsedName(self,[Implicit]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(Subscribe,[Default]), UsedName(receive,[Default]), UsedName(Unsubscribe,[Default]), UsedName(eq,[Default]), UsedName(supervisorStrategy,[Default]), UsedName(Receive,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator has the following implicit definitions changed:
[debug] 	UsedName(context,[Implicit]), UsedName(self,[Implicit]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Client...
[debug] Initial set of included nodes: StorageClient.Client
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Client)
[debug] Change NamesChange(StorageClient.Client,ModifiedNames(changes = UsedName(process,[Default]), UsedName($asInstanceOf,[Default]), UsedName(aroundPreRestart,[Default]), UsedName(aroundPostRestart,[Default]), UsedName(Process,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(preStart,[Default]), UsedName(aroundPreStart,[Default]), UsedName(Connect,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(aroundPostStop,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(Client,[Default]), UsedName(finalize,[Default]), UsedName(postRestart,[Default]), UsedName(context,[Implicit]), UsedName(synchronized,[Default]), UsedName(StorageClient;Client;init;,[Default]), UsedName(unhandled,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(sender,[Default]), UsedName(aroundReceive,[Default]), UsedName(isInstanceOf,[Default]), UsedName(preRestart,[Default]), UsedName(getClass,[Default]), UsedName(postStop,[Default]), UsedName(self,[Implicit]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(receive,[Default]), UsedName(eq,[Default]), UsedName(supervisorStrategy,[Default]), UsedName(Receive,[Default]))) invalidates 1 classes due to The StorageClient.Client has the following implicit definitions changed:
[debug] 	UsedName(context,[Implicit]), UsedName(self,[Implicit]).
[debug]   > by transitive inheritance: Set(StorageClient.Client)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.NotSubscribed...
[debug] Initial set of included nodes: Pubs.PubSubMediator.NotSubscribed
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.NotSubscribed)
[debug] Change NamesChange(Pubs.PubSubMediator.NotSubscribed,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(NotSubscribed,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unsubscribe,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(Pubs;PubSubMediator;NotSubscribed;init;,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.NotSubscribed has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(NotSubscribed,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(unsubscribe,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(Pubs;PubSubMediator;NotSubscribed;init;,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.NotSubscribed)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Client.Process...
[debug] Initial set of included nodes: StorageClient.Client.Process
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Client.Process)
[debug] Change NamesChange(StorageClient.Client.Process,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(Process,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]))) invalidates 1 classes due to The StorageClient.Client.Process has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(productPrefix,[Default]), UsedName(Process,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Client.Process)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage.Put...
[debug] Initial set of included nodes: StorageClient.Storage.Put
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage.Put)
[debug] Change NamesChange(StorageClient.Storage.Put,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(value,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(Put,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(StorageClient;Storage;Put;init;,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The StorageClient.Storage.Put has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(value,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(Put,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(key,[Default]), UsedName(StorageClient;Storage;Put;init;,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage.Put)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Storage.Ack...
[debug] Initial set of included nodes: StorageClient.Storage.Ack
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Storage.Ack)
[debug] Change NamesChange(StorageClient.Storage.Ack,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(Ack,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]))) invalidates 1 classes due to The StorageClient.Storage.Ack has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(Ack,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Storage.Ack)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs...
[debug] Initial set of included nodes: Pubs
[debug] Invalidated by transitive inheritance dependency: Set(Pubs)
[debug] Change NamesChange(Pubs,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(Pubs,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName(PubSubMediator,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(eq,[Default]))) invalidates 1 classes due to The Pubs has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(Pubs,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(notifyAll,[Default]), UsedName(PubSubMediator,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(eq,[Default]).
[debug]   > by transitive inheritance: Set(Pubs)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Publish...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Publish
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Publish)
[debug] Change NamesChange(Pubs.PubSubMediator.Publish,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(Publish,[Default]), UsedName(Pubs;PubSubMediator;Publish;init;,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(message,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Publish has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(copy$default$2,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName(Publish,[Default]), UsedName(Pubs;PubSubMediator;Publish;init;,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(curried,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(message,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(tupled,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Publish)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from StorageClient.Client.Connect...
[debug] Initial set of included nodes: StorageClient.Client.Connect
[debug] Invalidated by transitive inheritance dependency: Set(StorageClient.Client.Connect)
[debug] Change NamesChange(StorageClient.Client.Connect,ModifiedNames(changes = UsedName(StorageClient;Client;Connect;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(Connect,[Default]), UsedName(hashCode,[Default]), UsedName(storage,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The StorageClient.Client.Connect has the following regular definitions changed:
[debug] 	UsedName(StorageClient;Client;Connect;init;,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(Connect,[Default]), UsedName(hashCode,[Default]), UsedName(storage,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(StorageClient.Client.Connect)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.GetSubscribers...
[debug] Initial set of included nodes: Pubs.PubSubMediator.GetSubscribers
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.GetSubscribers)
[debug] Change NamesChange(Pubs.PubSubMediator.GetSubscribers,ModifiedNames(changes = UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(GetSubscribers,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(Pubs;PubSubMediator;GetSubscribers;init;,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.GetSubscribers has the following regular definitions changed:
[debug] 	UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(GetSubscribers,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(topic,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(Pubs;PubSubMediator;GetSubscribers;init;,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.GetSubscribers)
[debug]   > 
[debug]   > 
[debug]         
[debug] Invalidating (transitively) by inheritance from Pubs.PubSubMediator.Subscribed...
[debug] Initial set of included nodes: Pubs.PubSubMediator.Subscribed
[debug] Invalidated by transitive inheritance dependency: Set(Pubs.PubSubMediator.Subscribed)
[debug] Change NamesChange(Pubs.PubSubMediator.Subscribed,ModifiedNames(changes = UsedName(Subscribed,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(Pubs;PubSubMediator;Subscribed;init;,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(subscribe,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]))) invalidates 1 classes due to The Pubs.PubSubMediator.Subscribed has the following regular definitions changed:
[debug] 	UsedName(Subscribed,[Default]), UsedName($asInstanceOf,[Default]), UsedName(compose,[Default]), UsedName(productPrefix,[Default]), UsedName(Pubs;PubSubMediator;Subscribed;init;,[Default]), UsedName(equals,[Default]), UsedName(##,[Default]), UsedName(hashCode,[Default]), UsedName($isInstanceOf,[Default]), UsedName(toString,[Default]), UsedName(copy,[Default]), UsedName(copy$default$1,[Default]), UsedName(==,[Default]), UsedName(asInstanceOf,[Default]), UsedName(canEqual,[Default]), UsedName(notify,[Default]), UsedName(finalize,[Default]), UsedName(synchronized,[Default]), UsedName(clone,[Default]), UsedName(!=,[Default]), UsedName(subscribe,[Default]), UsedName(productArity,[Default]), UsedName(unapply,[Default]), UsedName(notifyAll,[Default]), UsedName($init$,[Default]), UsedName(andThen,[Default]), UsedName(isInstanceOf,[Default]), UsedName(getClass,[Default]), UsedName(ne,[Default]), UsedName(wait,[Default]), UsedName(productIterator,[Default]), UsedName(productElement,[Default]), UsedName(eq,[Default]), UsedName(apply,[Default]).
[debug]   > by transitive inheritance: Set(Pubs.PubSubMediator.Subscribed)
[debug]   > 
[debug]   > 
[debug]         
[debug] New invalidations:
[debug] Initial set of included nodes: 
[debug] Previously invalidated, but (transitively) depend on new invalidations:
[debug] Final step, transitive dependencies:
[debug] 	Set()
[debug] No classes were invalidated.
[debug] Scala compilation took 3.2894492 s
[info] done compiling
